'use strict'

// Do this as the first thing so that any code reading it knows the right env.
// This makes some libraries (like react) have better builds for production
process.env.NODE_ENV = 'production'

/*
Instead of running webpack using the cli in npm scripts, since we want to do
certain things before and after the build, we have this file run webpack.
We still keep it simple.
*/

const fs = require('fs-extra')
const chalk = require('chalk')
const webpack = require('webpack')

const paths = require('../config/paths')
const log = require('./log')
const webpackConfig = require('../config/webpack.config.prod')


// empty any existing build folder so we can start from scratch
fs.emptyDirSync(paths.appBuild)

// Copy stuff in our public folder over to our build folder
// This is where things like favicons or manifests, etc are copied
copyPublicFolder()

// Now we can create our build, we just let the developer know
log(chalk.cyan('Generating the build...\n'))

// Compile everything with webpack
const compiler = webpack(webpackConfig, (err, stats) => {
  if(err){
    log(chalk.red('Failed to compile.\n'))
    log(err)
    process.exit(1)
  }

  log(stats.toString({
    colors: true,
    modules: false,
    entrypoints: false
  }))

  log(chalk.cyan('\nBuild Complete!') + ' Everything can be served from the '+chalk.green('build')+' folder\n')
  // done
  process.exit(0)
})



/*
Copy contents of public folder into our build folder
(excluding the html file, which is generated by the webpack build)
*/
function copyPublicFolder() {
  fs.copySync(paths.appPublic, paths.appBuild, {
    dereference: true,
    filter: file => file !== paths.appHtml,
  });
}
